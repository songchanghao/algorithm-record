#### 那些插队的人

你有一个长度为 n 的队伍，从左到右依次为 1~n，有 m 次插队行为，用数组 cutIn 进行表示，cutIn 的元素依次代表想要插队的人的编号，每次插队，这个人都会直接移动到队伍的最前方。你需要返回一个整数，代表这 m 次插队行为之后，有多少个人已经不在原来队伍的位置了。

**示例 1:**

```
输入: 3,[3,2,3]
输出: 2 
解释: 
初始队伍为 [1, 2, 3]
3 开始插队 [3, 1, 2]
2 开始插队 [2, 3, 1]
3 开始插队 [3, 2, 1]
所以2还在原来的尾置，3和1两个人已经不在原来的位置了。
```

**示例 2:**

```
输入: 3,[]
输出: 0 
解释: 没有人进行插队，所有人都在自己原来的位置上。
```

​	“呐，西片，我们比比吧~到校门为止，拿的冰块大的就算赢，输的人要给赢的人暖手噢~”【今天也是为太太疯狂打call的一天（//▽//）】今天打卡一个历史遗留问题，感觉对python党很容易就能解决，但对于C++党来说真是当头一棒，只能返回迭代器的Vector在查找过程中无限超时，模拟这个插队过程只能通过很少一部分，于是只能另辟蹊径从规律角度出发，参考了一个很绝妙的题解。

​	首先用一个比较简单的例子来说明这个规律。如队列有8个人，插队序列为[5,2,3,5,6]

​	初始序列为[1,2,3,4,5,6,7,8]

​	第一次插队[5,1,2,3,4,6,7,8]

​	第二次插队[2,5,1,3,4,6,7,8]

​	第三次插队[3,2,5,1,4,6,7,8]

​	第四次插队[5,3,2,1,4,6,7,8]

​	第五次插队[6,5,**3**,2,1,4,**7**,**8**]

​	最终可以看到只有3,7,8在原来的位置，而1,2,4,5,6都已经不在原来的位置了，那这里有什么规律呢？

​	1.可以看到插队序列中最大值为6，也就是只有6之前的在进行插队操作，所以6之后的序列**一定保持不变**。

​	2.假设有一个人插了很多次队，那么**最后一次插队才是他最终的位置**，所以只考虑最后一次插队即可。

​	3.假设插队序列中最大值为max，那么我们的目标转换为求[1,max]中有多少个人不在自己的位置上。其实这个问题等价于求多少人在正确的位置上，因为**在正确位置的人一定插过队**，否则会被插队的人挤到后面去。因此可以可以比较插队后的位置和实际位置判断这个人是否在正确的位置。

​	4.由于插队的性质，对插队序列只保留最后一次出现的数字并逆置后恰好是最终序列的前几位

​		[5,2,3,5,6]—>[2,3,5,6]—>[6,5,3,2]—>[**6,5,3,2**,1,4,7,8]

​	综上所述规律，本题化为从后往前遍历去重后序列，比较是否和当前位置相等即可，代码如下：

```c++
class Solution {

public:

  int countDislocation(int n, vector<int>& cutIn) {
        //记录每个人插队的次数，set也可以
        unordered_map<int,int> vis;
      	//cnt每次递增，代表从0到第cnt个位置，maxv表示插队的最大值，right表示还在原来位置的人
        int cnt = 0,maxv = 0,right = 0;
      	//从后往前遍历，将第一次插队的人计入字典，若用set直接去重不需此操作
        for(int i = cutIn.size()-1; ~i; -- i) {
            if(!vis.count(cutIn[i]-1)) {
                vis[cutIn[i]-1] = 1;
                //插队的人还在原位置
                if(cutIn[i]-1 == cnt++) right ++;
                maxv = max(maxv,cutIn[i]);
            }
        }
      	//插队的最大值-在原位置的人=不在原位置的人
        return maxv-right;
  }

};
```

